#!/usr/bin/ruby

require 'optparse'
require 'ostruct'

class X11Window
	attr_reader :id, :process_name, :app_name, :pid, :title

	def initialize(options)
		options.each { |k,v| instance_variable_set("@#{k}", v) }

		@closed = false
	end

	def closed?
		return true if @closed

		begin
			Process.getpgid(@pid)
			false
		rescue Errno::ESRCH
			@closed = true
			true
		end
	end

	def kill
		system("kill -9 #{@pid}")
		puts "Kill result: #{$?} #{@app_name}"
	end

	def close
		system("wmctrl -ic \"#{@id}\"")
		puts "Close result: #{$?} #{@app_name}"
	end

	def open?
		return ! @closed
	end

	def wait_until_close
		max_polls = (@max_wait/@poll_interval).to_i

		wait_thread = Thread.new {
			max_polls.times do
				sleep @poll_interval

				if closed?
					break
				end
			end
		}

		wait_thread.join(@max_wait);
		puts "Stop wait #{@pid} #{@app_name}"
	end
end

class X11WindowCloser
	def initialize
		# default settings
		@options = {
			:simulate         => false,
			:force            => false,
			:poll_interval    => 0.5,
			:max_wait         => 5
		}

		# get cli options
		update_options()

		puts @options

		puts "=====================\n    SIMULATING\n=====================" if @options[:simulate]
	end

	def update_options
		opt_parser = OptionParser.new do |opts|
			opts.on("--force", "Kill all windows that remain open after",
			                   "waiting for them to terminate gracefully.\n\n"
			) do
				@options[:force] = true
			end

			opts.on("--simulate", "Test running the script without actually",
			                   "closing any windows. Usefull for debugging",
			                   "or for trying out sensitive settings.\n\n"
			) do
				@options[:simulate] = true
			end

			opts.on("--only [x,y,z]", Array, "Narrow down the windows to be closed by",
			                                 "comma separated list of PIDs.\n\n"
			) do |pids|
				puts "ONLY: #{pids}"
				@options[:only] = pids.map{|pid| pid.to_i}
			end

			opts.on("--max-wait val", Integer, "Set the max amount of time in seconds to",
			                                   "wait for windows to close.",
			                                   "Default is 5 seconds.\n\n"
			) do |seconds|
				@options[:max_wait] = seconds
			end

			opts.on("--poll-interval val", Float, "Set poll interval in seconds.",
			                                      "Default is 0.5 seconds.\n\n"
			) do |seconds|
				@options[:poll_interval] = seconds
			end

			opts.on("--except [x,y,z]", Array, "Exclude windows from being closed.",
			                                   "Comma separated list of PIDs.\n\n"
			) do |pids|
				@options[:except] = pids.map{|pid| pid.to_i}
			end

			opts.on("--help", "Print help text.") do |pids|
				puts opts
				abort
			end
		end

		opt_parser.order!(ARGV)
	end

	def get_open_windows
		windows = []

		`wmctrl -lp`.split("\n").each do |line|
			line_array = line.split(/\s+/)

			id    = line_array.shift      # 0
			line_array.shift              # 1 remove unkown element
			pid   = line_array.shift.to_i # 2
			line_array.shift              # 3 remove unkown element
			title = line_array.join(' ')  # 4 join the rest

			# for some windows
			# wmctrl can't determine
			# the window id or pid
			# e.g. steam
			# check `ps -A | grep steam`
			# possible steam client runs
			# outside of window manager
			# possibly solveable via specific
			# application extensions
			# or other window lookup/polling method
			next if pid == 0

			# filter windows
			next if @options[:except] && @options[:except].include?(pid)
			next if @options[:only] && ! @options[:only].include?(pid)


			process_name = ''
			app_name     = ''

			process_name = `ps -fwwp #{pid} | tail -n 1`.split(" ")[7] unless pid == 0

			if process_name != ''
				desktop_file = "/usr/share/applications/#{process_name}.desktop"
				app_name     = `cat #{desktop_file} | grep Name= | head -n 1 | cut -d= -f 2`.strip if File.exists?(desktop_file)
			end

			window_options = {
				:id            => id,
				:process_name  => process_name,
				:app_name      => app_name,
				:pid           => pid,
				:title         => title,
				:poll_interval => @options[:poll_interval],
				:max_wait      => @options[:max_wait]
			}

			puts window_options

			windows << X11Window.new(window_options)
		end

		return windows
	end

	def all_windows_closed?(windows)
		windows.each do |win|
			return false unless win.closed?
		end

		return true;
	end

	# takes array of X11Window objects
	# and a block that tries to close
	# the window
	#
	def close_windows_and_wait(windows, &block)
		close_threads = []

		windows.each do |win|
			next if win.closed?

			close_threads << Thread.new {
				# block passes in the close command
				block.call(win) unless @options[:simulate]
				win.wait_until_close
				puts "Closed (#{win.pid}) #{win.process_name}: #{win.app_name}"
			}
		end

		close_threads.each{|t|
			t.join(@options[:max_wait])
		}
	end

	def close_all_windows
		open_windows = get_open_windows()

		# load config
		# with custom close command

		# gently close windows
		puts "Closing"
		close_windows_and_wait(open_windows) do |win|
			# run custom close command here
			puts "Closing #{win.pid} #{win.app_name}"
			win.close
		end

		# kill remaining windows
		if @options[:force]
			puts "Killing"
			close_windows_and_wait(open_windows) do |win|
				puts "Killing #{win.pid} #{win.app_name}"
				win.kill
			end
		end

		if all_windows_closed?(open_windows)
			exit(0)
		end

		warn "Closing all windows failed."
		exit(1)
	end
end

X11WindowCloser.new.close_all_windows()