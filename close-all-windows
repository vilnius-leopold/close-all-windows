#!/usr/bin/ruby

require 'optparse'
require 'ostruct'

class X11WindowCloser
	def initialize

		# default settings
		@options = {
			:simulate         => false,
			:force            => false,
			:ensure_run       => false,
			:poll_interval    => 0.5,
			:max_wait         => 5,
			:callback_command => ''
		}

		update_options()

		puts "OPTIONS: #{@options.inspect}"
		puts "=====================\n    SIMULATING\n=====================" if @options[:simulate]

		at_exit{puts "Exiting!" }
	end

	def update_options
		opt_parser = OptionParser.new do |opts|
			opts.banner = "Usage: close-all-windows [options] [command]\n\nOptions:"

			opts.on("--force", "Kill all windows that remain open after",
			                   "waiting for them to terminate gracefully.\n\n"
			) do
				@options[:force] = true
			end

			opts.on("--simulate", "Test running the script without actually",
			                   "closing any windows. Usefull for debugging",
			                   "or for trying out sensitive settings.\n\n"
			) do
				@options[:simulate] = true
			end

			opts.on("--ensure-run", "Ensure that the callback command is run",
			                        "even if not all windows closed in time.\n\n"
			) do
				@options[:ensure_run] = true
			end

			opts.on("--only [x,y,z]", Array, "Narrow down the windows to be closed by",
			                                 "comma separated list of PIDs.\n\n"
			) do |pids|
				puts "ONLY: #{pids}"
				@options[:only] = pids.map{|pid| pid.to_i}
			end

			opts.on("--max-wait val", Integer, "Set the max amount of time in seconds to",
			                                   "wait for windows to close.",
			                                   "Default is 5 seconds.\n\n"
			) do |seconds|
				@options[:max_wait] = seconds
			end

			opts.on("--poll-interval val", Float, "Set poll interval in seconds.",
			                                      "Default is 0.5 seconds.\n\n"
			) do |seconds|
				@options[:poll_interval] = seconds
			end

			opts.on("--except [x,y,z]", Array, "Exclude windows from being closed.",
			                                   "Comma separated list of PIDs.\n\n"
			) do |pids|
				@options[:except] = pids.map{|pid| pid.to_i}
			end

			opts.on("--help", "Print help text.") do |pids|
				puts opts
				puts "\nCommand: optional callback to run after windows closed.\n\n"
				abort
			end
		end


		@options[:callback_command] = opt_parser.order!(ARGV).join(' ').strip
	end

	def get_open_windows
		windows = []

		`wmctrl -lp`.split("\n").each do |line|
			line_array = line.split(/\s+/)

			pid = line_array[2].to_i
			puts "LINE: #{line}"

			next if @options[:except] && @options[:except].include?(pid)
			next if @options[:only] && ! @options[:only].include?(pid)


			windows << {
				:win_id   => line_array[0],
				:p_name   => `ps -A | grep #{pid} | rev | cut -d\\  -f 1 | rev`.strip,
				:app_name => `cat /usr/share/applications/$(ps -p #{pid} -o comm=).desktop | grep Name= | head -n 1 | cut -d= -f 2`.strip,
				:pid      => pid,
				:title    => line_array[4]
			}
		end

		return windows
	end

	def close_window(win)
		command = "wmctrl -ic \"#{win[:win_id]}\""

		puts "closing #{win[:title]} #{command}"

		system(command) unless @options[:simulate]

		puts "#{win[:title]} SUCESS: #{$?.success?}" unless @options[:simulate]
	end

	def process_terminated?(pid)
		begin
			Process.getpgid( pid )
			false
		rescue Errno::ESRCH
			true
		end
	end

	def wait_for_process_to_close(pid)
		max_polls = (@options[:max_wait]/@options[:poll_interval]).to_i

		puts("max_polls #{max_polls}")

		wait_thread = Thread.new {
			max_polls.times do
				sleep @options[:poll_interval]

				if process_terminated?(pid)
					puts("Process terminated #{pid}")
					break
				end

				puts("Process still running #{pid}")
			end
		}

		wait_thread.join(@options[:max_wait]);
	end

	def close_window_and_wait(win)
		close_window(win)
		wait_for_process_to_close(win[:pid])
	end

	def all_windows_closed?(windows)
		windows.each do |win|
			return false unless process_terminated?(win[:pid])
		end

		return true;
	end

	def close_all_open_windows_and_wait
		puts("START")

		close_threads = []

		open_windows = get_open_windows()

		puts("Open Windows:\n#{open_windows}")

		open_windows.each do |win|
			close_threads << Thread.new {
				local_win = win
				puts("CLOSING '#{local_win[:p_name]}'")
				close_window_and_wait(local_win)
				puts("CLOSED #{local_win[:app_name]} '#{local_win[:p_name]}'")
			}

			puts("thread pushed '#{win[:title]}'")
		end

		close_threads.each{|t|
			puts("thread wait join")
			t.join(@options[:max_wait])
			puts("thread joined")
		}

		puts("DONE")

		callback_command = @options[:callback_command]

		# only run callback if exists
		# only run callback if all
		# windows closed in time
		# or if --ensure-run flag is set
		if ! callback_command.empty? &&
		( @options[:ensure_run] || all_windows_closed?(open_windows) )
			puts("Executing callback: #{callback_command}")
			Process.spawn(callback_command)
		end

		puts("TERMINATING")
	end
end

X11WindowCloser.new.close_all_open_windows_and_wait()